{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Psibyl Docs", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-psibyl-docs", 
            "text": "", 
            "title": "Welcome to Psibyl Docs"
        }, 
        {
            "location": "/installation/basic-installation/", 
            "text": "The following prerequisites are required to install Psibyl.\n\n\n\n\nSilverlight\n\n\nIIS Express\n\n\nSQL Server\n\n\n\n\n1. Download and extract the prerequisites from here.\n\n\n2. Install each of the prerequisites above seperately from the extracted prerequisites.\n\n\n3. Download and install the latest version of Psibyl from here.\n\n\n4. Go to the Start menu and seach for \"Psibyl\". Select the shortcut called \"Psibyl - Config\"\n\n\n5. Enter in the connection details for the SQL Server. The default server for a SQL Server Express installation is \".\\SQLExpress\" using windows authentication.\n\n\nIf the database does not exist it will be created automatically for you when the Psibyl Server is started. Otherwise, the existing database will be used. If you have an old version of the Psibyl database and you wish to migrate the data to the new version, please see Psibyl DB Migration\n\n\n6.  Press Windows Key + R and type \"services.msc\". Locate the service called \"Psibyl\" and restart it.\n\n\n\n\nMake sure that the \"Log On As\" account has sufficient access to the SQL Server and the installation directory.\n\n\n7. Browse to the Psibyl install location (default is C:\\Program Files (x86)\\Blue Nickel Solutions\\Psibyl). Navigate to the Server\\Logs and check that the database was connected to successfully.\n\n\n2015-04-23 14:21:54Z [4] Information Psibyl Server 0: Log Directory is 'C:\\Program Files (x86)\\Blue Nickel Solutions\\Psibyl\\Server\\Log'\n2015-04-23 14:21:54Z [4] Information Psibyl Server 0: Starting Psibyl Service\n2015-04-23 14:21:54Z [4] Verbose Psibyl Server 0: Starting Http Self Host Server\n2015-04-23 14:21:54Z [4] Verbose Psibyl Server 0: Initializing Database\n2015-04-23 14:22:01Z [4] Information Psibyl Server 0: Psibyl Service started at http://localhost:9000/", 
            "title": "Basic Installation"
        }, 
        {
            "location": "/installation/basic-installation/#1-download-and-extract-the-prerequisites-from-here", 
            "text": "", 
            "title": "1. Download and extract the prerequisites from here."
        }, 
        {
            "location": "/installation/basic-installation/#2-install-each-of-the-prerequisites-above-seperately-from-the-extracted-prerequisites", 
            "text": "", 
            "title": "2. Install each of the prerequisites above seperately from the extracted prerequisites."
        }, 
        {
            "location": "/installation/basic-installation/#3-download-and-install-the-latest-version-of-psibyl-from-here", 
            "text": "", 
            "title": "3. Download and install the latest version of Psibyl from here."
        }, 
        {
            "location": "/installation/basic-installation/#4-go-to-the-start-menu-and-seach-for-psibyl-select-the-shortcut-called-psibyl-config", 
            "text": "", 
            "title": "4. Go to the Start menu and seach for \"Psibyl\". Select the shortcut called \"Psibyl - Config\""
        }, 
        {
            "location": "/installation/basic-installation/#5-enter-in-the-connection-details-for-the-sql-server-the-default-server-for-a-sql-server-express-installation-is-sqlexpress-using-windows-authentication", 
            "text": "If the database does not exist it will be created automatically for you when the Psibyl Server is started. Otherwise, the existing database will be used. If you have an old version of the Psibyl database and you wish to migrate the data to the new version, please see Psibyl DB Migration", 
            "title": "5. Enter in the connection details for the SQL Server. The default server for a SQL Server Express installation is \".\\SQLExpress\" using windows authentication."
        }, 
        {
            "location": "/installation/basic-installation/#6-press-windows-key-r-and-type-servicesmsc-locate-the-service-called-psibyl-and-restart-it", 
            "text": "Make sure that the \"Log On As\" account has sufficient access to the SQL Server and the installation directory.", 
            "title": "6.  Press Windows Key + R and type \"services.msc\". Locate the service called \"Psibyl\" and restart it."
        }, 
        {
            "location": "/installation/basic-installation/#7-browse-to-the-psibyl-install-location-default-is-cprogram-files-x86blue-nickel-solutionspsibyl-navigate-to-the-serverlogs-and-check-that-the-database-was-connected-to-successfully", 
            "text": "2015-04-23 14:21:54Z [4] Information Psibyl Server 0: Log Directory is 'C:\\Program Files (x86)\\Blue Nickel Solutions\\Psibyl\\Server\\Log'\n2015-04-23 14:21:54Z [4] Information Psibyl Server 0: Starting Psibyl Service\n2015-04-23 14:21:54Z [4] Verbose Psibyl Server 0: Starting Http Self Host Server\n2015-04-23 14:21:54Z [4] Verbose Psibyl Server 0: Initializing Database\n2015-04-23 14:22:01Z [4] Information Psibyl Server 0: Psibyl Service started at http://localhost:9000/", 
            "title": "7. Browse to the Psibyl install location (default is C:\\Program Files (x86)\\Blue Nickel Solutions\\Psibyl). Navigate to the Server\\Logs and check that the database was connected to successfully."
        }, 
        {
            "location": "/integration/psibyl-integration-direct/", 
            "text": "Psibyl Control Integration (Direct)\n\n\nThis page details the process for integrating Psibyl into an execution platform which will run the Psiybl controller.\n\n\nOverview\n\n\nThe following sections will decscribe each step required for setting up and running a Psibyl controller from a Visual Studio project.\n\n\n\n\n\n\nPsibyl Control Integration (Direct)\n\n\nOverview\n\n\nSupported Platforms\n\n\nDependencies\n\n\nProject assembly references\n\n\nRegistering the control platform\n\n\nCreating a controller\n\n\nManaging a controller\n\n\nUpdating a controller's model\n\n\nUpdating a CV property\n\n\nUpdating a MV property\n\n\nUpdate a Disturbance property\n\n\nUpdating MV Gain Multipliers\n\n\nUpdating Disturbance Gain Multipliers\n\n\nResetting Predictions\n\n\nAccessing prediction results from execution\n\n\nTracing/Logging\n\n\nSample Program\n\n\n\n\n\n\n\n\n\n\nSupported Platforms\n\n\nThe Psibyl controller targets the .Net 4.0 platform and above. If you're project targets .Net 3.5 or below you will need to upgrade it to target .Net 4.0 or higher.\n\n\nDependencies\n\n\nThe Psibyl controller has a dependency on the CentreSpace NMath 5.02 library. These libraries are not included in the Psibyl installer due to their size. You can download the NMath installer from Installation Prerequisites.\n\n\nProject assembly references\n\n\nThere are four Psibyl .Net dlls that must be included in your project. These are,\n\n\n\n\nPsybil.Common.dll\n\n\nPsybil.Core.dll\n\n\nPsibyl.Client.dll\n\n\nPsibyl.Execution.dll\n\n\n\n\nIn addition to these assemblies, you must install the Microsoft Async Nu-Get package. You can do this with the following command in the Package Manager Console.\nInstall-Package Microsoft.Bcl.Async\nThis will add the following additional dlls that must be deployed with your application.\n\n\n\n\nSystem.Runtime.dll\n\n\nSystem.Threading.Tasks.dll\n\n\nSystem.IO.dll\n\n\nMicrosoft.Threading.Tasks.dll\n\n\nMicrosoft.Threading.Tasks.Extensions.Desktop.dll\n\n\nMicrosoft.Threading.Tasks.Extensions.dll\n\n\n\n\nNote:\n This only applies when integrating with an application built on .Net 4.0. When using .Net 4.5, you just need to add the assemblies normally in Visual Studio.\n\n\nRegistering the control platform\n\n\nIn order for clients to be aware of and communicate with controllers, the \"control platform\" or the application that creates and executes the MPC controller, must register itself with the Psibyl server. Clients are then able to see all available control platforms and the controllers executing on each of these.\n\n\nThe following code snippet demonstrates how to initialize and register the control platform.\n\n\nPsibylControl.RegisterControlPlatform(\"http://localhost:9000/api\", \"My MPC Control App\");\n\n\nNote that doing this is optional and may be left out, but if it is left out, the Web UI will not be able to receive any information about the controller.\n\n\nCreating a controller\n\n\nThe following code snippets demonstrates how to create a controller. In order to create a controller you must first create or retrieve an MPC Model. This is normally an MPC model created from the Web UI. You will need to include the namespace, \nPsibyl.Client\n and \nPsibyl.Core\n.\n\n\nPsibylClient client = new PsibylClient(\nhttp://localhost:9000/api\n);\nMPCModel model = client.MPCModels.Get(1);\nController controller = new Controller(model);\n\n\n\n\nYou can also retrieve an MPC model usiing the model's name.\n\n\nMPCModel model = client.MPCModels.GetByName(\"My MPC Model\");\n\n\nOnce a controller has been created using the code above, it's state will appear as \"Idle\" in the Web UI. \n\n\nManaging a controller\n\n\nThere are three main interaction points to be aware of when working with a Psibyl controller. These are Start, Stop and Execute. Starting a controller will initialize the controller from the MPC model putting it into a state where it is ready for execution. The controller will now be in a state \"Running\". You can start a controller using the following code.\n\n\ncontroller.Start();\n\n\nStopping a controller will unallocate any resources being used by the controller and put it back into the \"Idle\" state. You can stop a controller using the following code.\n\n\ncontroller.Stop();\n\n\nThe Execute method must be called on each controller iteration. You must pass the current CV's, MV's, DV's and SP's as double[] parameters. The method will return a double[] as the result. The following code demonstrates usage of the Execute method.\n\n\ndouble[] cvs = new double[] { 0 };\ndouble[] sps = new double[] { 0 };\ndouble[] mvs = new double[] { 0 };\ndouble[] dvs = new double[] {};\n\nbool run = true;\nbool quality = false; //This will contain the quality after the execute method has been called.\nint errorId = 0; //This will contain the error id, if any, after the execute method has been called.\n\nwhile (run)\n{\n    double[] result = controller.Execute(cvs, sps, dvs, mvs, ref quality, ref errorId); \n    Thread.Sleep(1000);\n}\n\n\n\n\nNote that the quality and errorId parameters are optional.\n\n\nUpdating a controller's model\n\n\nYou may change the controller's model at runtime using the following technique. This technique ensures that all clients are aware of the changes made to the model by the controller. The following code shows how to update the controllers model using the UpdateModel method.\n\n\nmodel.QPMaxIterations = 100;\nmodel.InputCVs[0].Weight = 0.5;\ncontroller.UpdateModel(model);\n\n\n\n\nOnce UpdateModel has been called the controller will re-initialize, copying the state parameters over from the previous instance. When the controller has finished re-initializing, it swaps itself out with the old instance.\n\n\nUpdating a CV property\n\n\nCV's can be updated by specifying the property and an array of values for for each Input CV using the \nUpdateInputCVValues\n on the controller client. The following code snippet demonstrates how this can be done.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First(); \n\n//For a controller with 2 Input CV's\ndouble[] weightValues = new double[] { 1.5, 2.5 };\nclient.Controllers.UpdateInputCVValues(controller.Id, \nWeight\n, weightValues);\n\n\n\n\nThe following is a list of properties that can be used.\n\n\n\n\nWeight\n\n\nIntegrating\n\n\nConstraintSofteningLowerWeight\n\n\nConstraintSofteningUpperWeight\n\n\nLowerConstraint\n\n\nLowerConstraintEnabled\n\n\nUpperConstraint\n\n\nUpperConstraintEnabled\n\n\nSoftLowerConstraint\n\n\nSoftLowerConstraintEnabled\n\n\nSoftUpperConstraint\n\n\nSoftUpperConstraintEnabled\n\n\nEnabled\n\n\nUpperRange\n\n\nLowerRange\n\n\n\n\nUpdating a MV property\n\n\nMV's properties can be updated much the same way as CV's using the UpdateOutputMVValues method on the controller client.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First(); \n\n//For a controller with 2 OutputMVs\ndouble[] values = new double[] { 2, 5 };\nclient.Controllers.UpdateOutputMVValues(controller.Id, \nMaxRateConstraint\n, values);\n\n\n\n\nThe following is a list of properties that can be used.\n\n\n\n\nMaxRateConstraint\n\n\nMinRateConstraint\n\n\nLowerConstraint\n\n\nLowerConstraintEnabled\n\n\nUpperConstraint\n\n\nUpperConstraintEnabled\n\n\nWeight\n\n\nMinimumStep\n\n\nEnabled\n\n\nUpperRange\n\n\nLowerRange\n\n\n\n\nUpdate a Disturbance property\n\n\nDisturbance properties can be updated much the same way as CV's and MV's using the \nUpdateDisturbanceValues\n method on the controller client.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\n\n//For a controller with 1 Disturbance\ndouble[] values = new double[] { 0 };\nlient.Controllers.UpdateDisturbanceValues(controller.Id, \nEnabled\n, values);\n\n\n\n\nThe following is a list of properties that can be used.\n\n\n\n\nEnabled\n\n\nUpperRange\n\n\nLowerRange\n\n\n\n\nUpdating MV Gain Multipliers\n\n\nMV gain multpliers can be updated using the UpdateMVGain method of the controller client. This is acheived by providing a 2D array to the method which represents the model matrix. Each element in the first array represents the Input CV and the elements of these arrays represent the CV/MV pair or step response. The following code snippet demonstrates the use of this method.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First(); \n\n//For a 2 x 2 controller with 2 Input CV's and 2 Output MV's\ndouble[][] gMult = new double[][]\n{\n    new double[] { 1, 1.5 },\n    new double[] { 1.2, 1 }\n};\n\nclient.Controllers.UpdateMVGain(controller.Id, gMult);\n\n\n\n\nUpdating Disturbance Gain Multipliers\n\n\nDisturbance gains are updated in the same way as MV gains except that the method used is  \nUpdateDisturbanceGain\n .\n\n\nResetting Predictions\n\n\nA controllers predictions can be reset using the ResetController method of the controller client. The following snippet demonstrates this.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\nclient.Controllers.ResetController(controller.Id );\n\n\n\n\nAccessing prediction results from execution\n\n\nThe following code snippet demostrates how the execution results can be accessed for trending purposes and other analysis.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\n\nControllerCurrentValues currentValues = new ControllerCurrentValues()\n{\n    CVs = new double[] { 0, 0 },\n    SPs = new double[] { 0, 0 },\n    MVs = new double[] { 0, 0 },\n    DVs = new double[] { 0, 0 },\n};\n\nControllerResult result = client.Controllers.ExecuteController(controller.Id, currentValues);\n\nfor (int i = 0; i \n result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int cvIndex = i % result.Diagnostic.Model.InputCVCount;\n    string cvName = result.Diagnostic.Model.InputCVsSequenced[cvIndex].Name;\n    double value = result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues[i].Value;\n    Console.WriteLine($\n{cvName}-YPredCL:{value}\n);\n}\nfor (int i = 0; i \n result.Diagnostic.YPredOLDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int cvIndex = i % result.Diagnostic.Model.InputCVCount;\n    string cvName = result.Diagnostic.Model.InputCVsSequenced[cvIndex].Name;\n    double value = result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues[i].Value;\n    Console.WriteLine($\n{cvName}-YPredOL:{value}\n);\n}\nfor (int i = 0; i \n result.Diagnostic.PredictedUStepsDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int mvIndex = i % result.Diagnostic.Model.OutputMVCount;\n    string mvName = result.Diagnostic.Model.OutputMVsSequenced[mvIndex].Name;\n    //Vector is also stepped, i.e each value is duplicated so that it can be trended as a step line.\n    double value = result.Diagnostic.PredictedUStepsDoubleVector.DoubleVectorValues[i + 1].Value;\n    Console.WriteLine($\n{mvName}-PredictedUSteps:{value}\n);\n}\n\n\n\n\nTracing/Logging\n\n\nThe Psibyl API provides a way to hook into the trace information which is generated by the controller. This mechanism is based on the System.Diagnostics API provided with the .Net Framework as well as a project called Essential diagnostics. You can obtain more information on these at the following links.\nhttps://msdn.microsoft.com/en-us/library/gg145030(v=vs.110).aspx\nhttps://essentialdiagnostics.codeplex.com/\n\n\nThe Psibyl API provides a simple way for adding Trace Listeners which will be used to log information and errors from the controller. Currently there are three different types of trace listeners that you can add. These are,\n\n\n\n\nEvent Log Trace Listener - Writes generated messages to the Windows Event log.\n\n\nRolling File Trace Listener - Writes generated messages to a rolling text file on the file system.\n\n\nColored Console Trace Listener - Writes generated message to the console window of the application.\n\n\n\n\nThe following code demonstrates how to add an Event Log Trace Listener. You will need to add the namespace \nPsibyl.Core\n.\n\n\nTracing.AddEventLogTraceListener(Tracing.ExecutionTrace, \nMy Application - Psibyl MPC\n);\n\n\n\n\nThe second parameter is the event log name. This is optional and the default \"Psibyl Execution\" will be used if not specified. You may use an existing event log or if the event log does not exist, one will be created using the event log name.\n\n\nSample Program\n\n\nBelow is the code for the full sample program used in the previous section.\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing Psibyl.Core;\nusing Psibyl.Core.Model;\nusing Psibyl.Execution;\nnamespace Psibyl.Test\n{\n    class Program\n    {\n        static void Main(string[] args)\n        { //Register the control plarform with the Psibyl Server. \n            PsibylControl.RegisterControlPlatform(\nhttp://localhost:9000/api\n, \nMy MPC Control App\n);\n\n            //Add the Event and Console listeners for tracing. \n            Tracing.AddEventLogTraceListener(Tracing.ExecutionTrace, \nMy Application - Psibyl MPC\n);\n            Tracing.AddColoredConsoleTraceListener(Tracing.ExecutionTrace);\n\n            //Create the Psibyl client which will be used to retrieve the model. \n            Psibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\n\n            //Fetch the MPC model using the model name. \n            MPCModel model = client.MPCModels.GetByName(\nMy MPC Model\n);\n\n            //Create the controller using the model retreived above. \n            Controller controller = new Controller(model);\n\n            //Start the controller \n            controller.Start();\n\n            //Create parameters for execute. The size of the arrays must match the model size; \n            double[] cvs = new double[] { 0 };\n            double[] sps = new double[] { 0 };\n            double[] mvs = new double[] { 0 };\n            double[] dvs = new double[] { };\n            bool run = true; bool quality = false;\n\n            //This will contain the quality after the execute method has been called. \n            int errorId = 0; //This will contain the error id, if any, after the execute method has been called. \n            int iterationToUpdateModel = 10; //The iteration at which an update will occur \n            int iteration = 0; //The current iteration \n\n            while (run)\n            {\n                if (iteration == iterationToUpdateModel)\n                {\n                    //Perform model update \n                    model.QPMaxIterations = 100;\n                    model.InputCVs[0].Weight = 0.5;\n                    controller.UpdateModel(model);\n                }\n                //Execute the controller \n                double[] result = controller.Execute(cvs, sps, dvs, mvs, ref quality, ref errorId);\n                //Put the thread to sleep for 1 second. This should match the sampling interval. \n                Thread.Sleep(1000); iteration++;\n            }\n            Console.ReadLine();\n        }\n    }\n}", 
            "title": "Direct Integration"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#psibyl-control-integration-direct", 
            "text": "This page details the process for integrating Psibyl into an execution platform which will run the Psiybl controller.", 
            "title": "Psibyl Control Integration (Direct)"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#overview", 
            "text": "The following sections will decscribe each step required for setting up and running a Psibyl controller from a Visual Studio project.    Psibyl Control Integration (Direct)  Overview  Supported Platforms  Dependencies  Project assembly references  Registering the control platform  Creating a controller  Managing a controller  Updating a controller's model  Updating a CV property  Updating a MV property  Update a Disturbance property  Updating MV Gain Multipliers  Updating Disturbance Gain Multipliers  Resetting Predictions  Accessing prediction results from execution  Tracing/Logging  Sample Program", 
            "title": "Overview"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#supported-platforms", 
            "text": "The Psibyl controller targets the .Net 4.0 platform and above. If you're project targets .Net 3.5 or below you will need to upgrade it to target .Net 4.0 or higher.", 
            "title": "Supported Platforms"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#dependencies", 
            "text": "The Psibyl controller has a dependency on the CentreSpace NMath 5.02 library. These libraries are not included in the Psibyl installer due to their size. You can download the NMath installer from Installation Prerequisites.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#project-assembly-references", 
            "text": "There are four Psibyl .Net dlls that must be included in your project. These are,   Psybil.Common.dll  Psybil.Core.dll  Psibyl.Client.dll  Psibyl.Execution.dll   In addition to these assemblies, you must install the Microsoft Async Nu-Get package. You can do this with the following command in the Package Manager Console.\nInstall-Package Microsoft.Bcl.Async\nThis will add the following additional dlls that must be deployed with your application.   System.Runtime.dll  System.Threading.Tasks.dll  System.IO.dll  Microsoft.Threading.Tasks.dll  Microsoft.Threading.Tasks.Extensions.Desktop.dll  Microsoft.Threading.Tasks.Extensions.dll   Note:  This only applies when integrating with an application built on .Net 4.0. When using .Net 4.5, you just need to add the assemblies normally in Visual Studio.", 
            "title": "Project assembly references"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#registering-the-control-platform", 
            "text": "In order for clients to be aware of and communicate with controllers, the \"control platform\" or the application that creates and executes the MPC controller, must register itself with the Psibyl server. Clients are then able to see all available control platforms and the controllers executing on each of these.  The following code snippet demonstrates how to initialize and register the control platform.  PsibylControl.RegisterControlPlatform(\"http://localhost:9000/api\", \"My MPC Control App\");  Note that doing this is optional and may be left out, but if it is left out, the Web UI will not be able to receive any information about the controller.", 
            "title": "Registering the control platform"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#creating-a-controller", 
            "text": "The following code snippets demonstrates how to create a controller. In order to create a controller you must first create or retrieve an MPC Model. This is normally an MPC model created from the Web UI. You will need to include the namespace,  Psibyl.Client  and  Psibyl.Core .  PsibylClient client = new PsibylClient( http://localhost:9000/api );\nMPCModel model = client.MPCModels.Get(1);\nController controller = new Controller(model);  You can also retrieve an MPC model usiing the model's name.  MPCModel model = client.MPCModels.GetByName(\"My MPC Model\");  Once a controller has been created using the code above, it's state will appear as \"Idle\" in the Web UI.", 
            "title": "Creating a controller"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#managing-a-controller", 
            "text": "There are three main interaction points to be aware of when working with a Psibyl controller. These are Start, Stop and Execute. Starting a controller will initialize the controller from the MPC model putting it into a state where it is ready for execution. The controller will now be in a state \"Running\". You can start a controller using the following code.  controller.Start();  Stopping a controller will unallocate any resources being used by the controller and put it back into the \"Idle\" state. You can stop a controller using the following code.  controller.Stop();  The Execute method must be called on each controller iteration. You must pass the current CV's, MV's, DV's and SP's as double[] parameters. The method will return a double[] as the result. The following code demonstrates usage of the Execute method.  double[] cvs = new double[] { 0 };\ndouble[] sps = new double[] { 0 };\ndouble[] mvs = new double[] { 0 };\ndouble[] dvs = new double[] {};\n\nbool run = true;\nbool quality = false; //This will contain the quality after the execute method has been called.\nint errorId = 0; //This will contain the error id, if any, after the execute method has been called.\n\nwhile (run)\n{\n    double[] result = controller.Execute(cvs, sps, dvs, mvs, ref quality, ref errorId); \n    Thread.Sleep(1000);\n}  Note that the quality and errorId parameters are optional.", 
            "title": "Managing a controller"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#updating-a-controllers-model", 
            "text": "You may change the controller's model at runtime using the following technique. This technique ensures that all clients are aware of the changes made to the model by the controller. The following code shows how to update the controllers model using the UpdateModel method.  model.QPMaxIterations = 100;\nmodel.InputCVs[0].Weight = 0.5;\ncontroller.UpdateModel(model);  Once UpdateModel has been called the controller will re-initialize, copying the state parameters over from the previous instance. When the controller has finished re-initializing, it swaps itself out with the old instance.", 
            "title": "Updating a controller's model"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#updating-a-cv-property", 
            "text": "CV's can be updated by specifying the property and an array of values for for each Input CV using the  UpdateInputCVValues  on the controller client. The following code snippet demonstrates how this can be done.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First(); \n\n//For a controller with 2 Input CV's\ndouble[] weightValues = new double[] { 1.5, 2.5 };\nclient.Controllers.UpdateInputCVValues(controller.Id,  Weight , weightValues);  The following is a list of properties that can be used.   Weight  Integrating  ConstraintSofteningLowerWeight  ConstraintSofteningUpperWeight  LowerConstraint  LowerConstraintEnabled  UpperConstraint  UpperConstraintEnabled  SoftLowerConstraint  SoftLowerConstraintEnabled  SoftUpperConstraint  SoftUpperConstraintEnabled  Enabled  UpperRange  LowerRange", 
            "title": "Updating a CV property"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#updating-a-mv-property", 
            "text": "MV's properties can be updated much the same way as CV's using the UpdateOutputMVValues method on the controller client.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First(); \n\n//For a controller with 2 OutputMVs\ndouble[] values = new double[] { 2, 5 };\nclient.Controllers.UpdateOutputMVValues(controller.Id,  MaxRateConstraint , values);  The following is a list of properties that can be used.   MaxRateConstraint  MinRateConstraint  LowerConstraint  LowerConstraintEnabled  UpperConstraint  UpperConstraintEnabled  Weight  MinimumStep  Enabled  UpperRange  LowerRange", 
            "title": "Updating a MV property"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#update-a-disturbance-property", 
            "text": "Disturbance properties can be updated much the same way as CV's and MV's using the  UpdateDisturbanceValues  method on the controller client.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\n\n//For a controller with 1 Disturbance\ndouble[] values = new double[] { 0 };\nlient.Controllers.UpdateDisturbanceValues(controller.Id,  Enabled , values);  The following is a list of properties that can be used.   Enabled  UpperRange  LowerRange", 
            "title": "Update a Disturbance property"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#updating-mv-gain-multipliers", 
            "text": "MV gain multpliers can be updated using the UpdateMVGain method of the controller client. This is acheived by providing a 2D array to the method which represents the model matrix. Each element in the first array represents the Input CV and the elements of these arrays represent the CV/MV pair or step response. The following code snippet demonstrates the use of this method.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First(); \n\n//For a 2 x 2 controller with 2 Input CV's and 2 Output MV's\ndouble[][] gMult = new double[][]\n{\n    new double[] { 1, 1.5 },\n    new double[] { 1.2, 1 }\n};\n\nclient.Controllers.UpdateMVGain(controller.Id, gMult);", 
            "title": "Updating MV Gain Multipliers"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#updating-disturbance-gain-multipliers", 
            "text": "Disturbance gains are updated in the same way as MV gains except that the method used is   UpdateDisturbanceGain  .", 
            "title": "Updating Disturbance Gain Multipliers"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#resetting-predictions", 
            "text": "A controllers predictions can be reset using the ResetController method of the controller client. The following snippet demonstrates this.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\nclient.Controllers.ResetController(controller.Id );", 
            "title": "Resetting Predictions"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#accessing-prediction-results-from-execution", 
            "text": "The following code snippet demostrates how the execution results can be accessed for trending purposes and other analysis.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\n\nControllerCurrentValues currentValues = new ControllerCurrentValues()\n{\n    CVs = new double[] { 0, 0 },\n    SPs = new double[] { 0, 0 },\n    MVs = new double[] { 0, 0 },\n    DVs = new double[] { 0, 0 },\n};\n\nControllerResult result = client.Controllers.ExecuteController(controller.Id, currentValues);\n\nfor (int i = 0; i   result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int cvIndex = i % result.Diagnostic.Model.InputCVCount;\n    string cvName = result.Diagnostic.Model.InputCVsSequenced[cvIndex].Name;\n    double value = result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues[i].Value;\n    Console.WriteLine($ {cvName}-YPredCL:{value} );\n}\nfor (int i = 0; i   result.Diagnostic.YPredOLDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int cvIndex = i % result.Diagnostic.Model.InputCVCount;\n    string cvName = result.Diagnostic.Model.InputCVsSequenced[cvIndex].Name;\n    double value = result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues[i].Value;\n    Console.WriteLine($ {cvName}-YPredOL:{value} );\n}\nfor (int i = 0; i   result.Diagnostic.PredictedUStepsDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int mvIndex = i % result.Diagnostic.Model.OutputMVCount;\n    string mvName = result.Diagnostic.Model.OutputMVsSequenced[mvIndex].Name;\n    //Vector is also stepped, i.e each value is duplicated so that it can be trended as a step line.\n    double value = result.Diagnostic.PredictedUStepsDoubleVector.DoubleVectorValues[i + 1].Value;\n    Console.WriteLine($ {mvName}-PredictedUSteps:{value} );\n}", 
            "title": "Accessing prediction results from execution"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#tracinglogging", 
            "text": "The Psibyl API provides a way to hook into the trace information which is generated by the controller. This mechanism is based on the System.Diagnostics API provided with the .Net Framework as well as a project called Essential diagnostics. You can obtain more information on these at the following links.\nhttps://msdn.microsoft.com/en-us/library/gg145030(v=vs.110).aspx\nhttps://essentialdiagnostics.codeplex.com/  The Psibyl API provides a simple way for adding Trace Listeners which will be used to log information and errors from the controller. Currently there are three different types of trace listeners that you can add. These are,   Event Log Trace Listener - Writes generated messages to the Windows Event log.  Rolling File Trace Listener - Writes generated messages to a rolling text file on the file system.  Colored Console Trace Listener - Writes generated message to the console window of the application.   The following code demonstrates how to add an Event Log Trace Listener. You will need to add the namespace  Psibyl.Core .  Tracing.AddEventLogTraceListener(Tracing.ExecutionTrace,  My Application - Psibyl MPC );  The second parameter is the event log name. This is optional and the default \"Psibyl Execution\" will be used if not specified. You may use an existing event log or if the event log does not exist, one will be created using the event log name.", 
            "title": "Tracing/Logging"
        }, 
        {
            "location": "/integration/psibyl-integration-direct/#sample-program", 
            "text": "Below is the code for the full sample program used in the previous section.  using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing Psibyl.Core;\nusing Psibyl.Core.Model;\nusing Psibyl.Execution;\nnamespace Psibyl.Test\n{\n    class Program\n    {\n        static void Main(string[] args)\n        { //Register the control plarform with the Psibyl Server. \n            PsibylControl.RegisterControlPlatform( http://localhost:9000/api ,  My MPC Control App );\n\n            //Add the Event and Console listeners for tracing. \n            Tracing.AddEventLogTraceListener(Tracing.ExecutionTrace,  My Application - Psibyl MPC );\n            Tracing.AddColoredConsoleTraceListener(Tracing.ExecutionTrace);\n\n            //Create the Psibyl client which will be used to retrieve the model. \n            Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\n\n            //Fetch the MPC model using the model name. \n            MPCModel model = client.MPCModels.GetByName( My MPC Model );\n\n            //Create the controller using the model retreived above. \n            Controller controller = new Controller(model);\n\n            //Start the controller \n            controller.Start();\n\n            //Create parameters for execute. The size of the arrays must match the model size; \n            double[] cvs = new double[] { 0 };\n            double[] sps = new double[] { 0 };\n            double[] mvs = new double[] { 0 };\n            double[] dvs = new double[] { };\n            bool run = true; bool quality = false;\n\n            //This will contain the quality after the execute method has been called. \n            int errorId = 0; //This will contain the error id, if any, after the execute method has been called. \n            int iterationToUpdateModel = 10; //The iteration at which an update will occur \n            int iteration = 0; //The current iteration \n\n            while (run)\n            {\n                if (iteration == iterationToUpdateModel)\n                {\n                    //Perform model update \n                    model.QPMaxIterations = 100;\n                    model.InputCVs[0].Weight = 0.5;\n                    controller.UpdateModel(model);\n                }\n                //Execute the controller \n                double[] result = controller.Execute(cvs, sps, dvs, mvs, ref quality, ref errorId);\n                //Put the thread to sleep for 1 second. This should match the sampling interval. \n                Thread.Sleep(1000); iteration++;\n            }\n            Console.ReadLine();\n        }\n    }\n}", 
            "title": "Sample Program"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/", 
            "text": "Psibyl Integration (REST/Web API)\n\n\nYou can facilitate the control of a Psibyl controller using a RESTful Web API. This is the simplest and easiest way to integrate Psibyl with control platforms that are not based on the .Net Framework.\n\n\n\n\n\n\nPsibyl Integration (REST/Web API)\n\n\nOverview\n\n\nCreate a Controller\n\n\nManaging a Controller\n\n\nExecuting a controller\n\n\nUpdating a Controller's Model\n\n\nUpdating a Controller's CV, MV and Disturbance Values\n\n\nUpdating a Controller's Gain\n\n\nUpdate MV Gain\n\n\n\n\n\n\nSample (Postman)\n\n\nCreate Controller\n\n\nStart Controller\n\n\nUpdate a controller\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOverview\n\n\nAt the core of Psibyl is a Web server which provides access to and storage of all MPC models. Any interaction with Psibyl requires that the Psibyl Server is running. Typically, control is done using a .Net library, provided with Psibyl, which is integrated directly into the control/execution platform (see Psibyl Controller Integration (.Net)). The Psibyl server hosts and provides access to this same API over a simple REST interface. Since any interprocess communication, from a non .Net process to a .Net process, is likely to be done with a TCP/IP protocol, it may be desirable to interact directly with the web server over TCP/IP and HTTP rather than having to write an additional interface. The following sections describe how to acheive this.\n\n\nCreate a Controller\n\n\nThe following URL demonstrates how to create a controller hosted on the Psibyl Server.\n\n\nGET -\n\n\nhttp://localhost:9000/api/controller/createcontroller?modelid={modelid}\n\n\nThe URL requires only the {modelid} which is an integer, identifying the model which will be used to create the controller. The following shows an example. \n\n\nGET -\n\n\nhttp://localhost:9000/api/controller/createcontroller?modelid=1\n\n\nWhen the request is completed you should receive a response containing something similar to the following JSON. Take note of the \"Id\" field. You will need this for all subsequent requests.\n\n\n\n{\n\n  \n$id\n:\n1\n,\n\n  \nId\n:\n302f5555-24fd-4d66-8335-2ae58c9b2119\n,\n\n  \nModel\n:\n\n  {\n\n    ... \n\n  },\n\n  \nExecutionState\n:0,\n\n  \nLookup\n:null,\n\n  \nCVConstraintStrategy\n:1,\n\n  \nQPSolver\n:null,\n\n  \nQPMaxIterations\n:50,\n\n  \nQPTollerance\n:0.0001,\n\n  \nPredictedCVsOL\n:null,\n\n  \nPredictedCVsCL\n:null,\n\n  \nModelId\n:1,\n\n  \nCurrentDiagnosticIteration\n:null\n\n}\n\n\n\n\n\nManaging a Controller\n\n\nOnce a controller has been created and you have the controller id, you can use the id to start and stop the controller. \n\n\nTo start the controller, use the following URL. This will initialize the controller, making it ready for execution. \n\n\nPOST -\n\n\nhttp://localhost:9000/api/controller/Start/302f5555-24fd-4d66-8335-2ae58c9b2119\n\n\nTo stop the controller you can use the following URL. Once the controller has been stopped you will no longer be able to execute it. \n\n\nPOST -\n\n\nhttp://localhost:9000/api/controller/Stop/302f5555-24fd-4d66-8335-2ae58c9b2119\n\n\nBoth requests will return a 'true' if the request succeeded. \n\n\nIf the request failed due to an incorrect controller id, you will receive the following error response.\n\n\n\n{\n\n  \nId\n:0,\n\n  \nMessage\n:\nAn error occured\n,\n\n  \nExceptionMessage\n:\nUnable to find a controller for given Id '1492b7b4-fcb7-40e0-9a83-bb5caf39318d' - Correlation Id: 1eb4db28-0376-4528-8532-eb72f8ae6e2f\n,\n\n  \nExceptionType\n:\nPsibyl.Service.CorrelationException\n,\n\n  \nStackTrace\n:null\n\n}\n\n\n\n\n\nWhen a controller has been stopped, you may wish to remove it from the server. You can do this with the following URL. \n\n\nDELETE -\n\n\nhttp://localhost:9000/api/controller/delete/302f5555-24fd-4d66-8335-2ae58c9b2119\n\n\nExecuting a controller\n\n\nOnce a controller is started you may execute it by using the Execute request. This must be down at each execution interval and the current values must be provided. Also, as most REST clients execute asynchronously, you must make sure that you have received a response for the current iteration before sending the Execute request again. I.e. executes should be synchronous. The following is the URL used to perform an execution of the controller. \n\n\nPOST -\n\n\nhttp://localhost:9000/api/controller/Execute/302f5555-24fd-4d66-8335-2ae58c9b2119\n\n\nThe following JSON must also be provided with this request. This describes the current values to give to the controller for a 1 x 1 model with no disturbances.\n\n\n\n{\n\n  \nCVs\n:[0],\n\n  \nSPs\n:[0],\n\n  \nMVs\n:[0],\n\n  \nDVs\n:[]\n\n}\n\n\n\n\n\nThe following is an example of a current values for a 2 x 2 model with 1 disturbace.\n\n\n\n{\n\n  \nCVs\n:[1,2],\n\n  \nSPs\n:[3,4],\n\n  \nMVs\n:[3,4],\n\n  \nDVs\n:[1]\n\n}\n\n\n\n\n\nThe response you will recieve from an Execute request will look as follows.\n\n\n\n{\n\n  \n$id\n:\n1\n,\n\n  \nResult\n:\n\n  {\n\n    \n$id\n:\n2\n,\n\n    \n$values\n:[0.8331979999999999]\n\n  },\n\n  \nQuality\n:true,\n\n  \nErrorId\n:0\n\n}\n\n\n\n\n\nUpdating a Controller's Model\n\n\nIn order to update the model of a controller, for example, changing weights, constraints and limits. You may use the UpdateModel request. The URL looks as follows. \n\n\nPOST -\n\n\nhttp://localhost:9000/api/controller/UpdateModel/302f5555-24fd-4d66-8335-2ae58c9b2119\n\n\nYou must provide the entire model in JSON to the request. This is best achieved by retrieving the model and then modifying the desired parameters. \n\n\nThe following URL demonstrates how to retrieve an MPC model. \n\n\nGET -\n\n\nhttp://localhost:9000/api/mpcmodel/Get/1\n\n\nThe response, which has been shortened for display purposes, should look as follows.\n\n\n\n{\n\n  \n$id\n:\n1\n,\n\n  \nDisturbances\n:\n\n  {\n\n    \n$id\n:\n2\n,\n\n    \n$values\n:[] \n\n  },\n\n  \nInputCVs\n:\n\n  {\n\n    ...\n\n  },\n\n  \nOutputMVs\n:\n\n  {\n\n    ...\n\n  },\n\n  \nId\n:1,\n\n  \nName\n: \nDemo Model\n,\n\n  \nLastUpdated\n:\n\\/Date(1427714090680+0200)\\/\n,\n\n  \nModelExecutionState\n:0,\n\n  \nPredictionHorizon\n:118,\n\n  \nControlHorizon\n:36,\n\n  \nModelHorizon\n:118,\n\n  \nSampleInterval\n:5,\n\n  \nConstraintSoftening\n:true,\n\n  \nDateCreated\n:\n\\/Date(1427714090680+0200)\\/\n,\n\n  \nDateModified\n:\n\\/Date(1427878418670+0200)\\/\n,\n\n  \nQPMaxIterations\n:50,\n\n  \nQPTolerance\n:0.0001,\n\n  \nSysIDResults\n:\n\n  {\n\n    ...\n\n  },\n\n  \nLastSampleInterval\n:10\n\n}\n\n\n\n\n\nOnce the changes have been made, they must be posted back to the Update Model method using the format above.\n\n\nUpdating a Controller's CV, MV and Disturbance Values\n\n\nIn order to update the values of a controller, you may use either the UpdateInputCVValues, UpdateOutputMVValues or the UpdateDisturbanceValues request. The URL for UpdateInputCVValues looks as follows. \n\n\nPOST -\n\n\nhttp://localhost:9000/api/controller/UpdateInputCVValues?controllerId=302f5555-24fd-4d66-8335-2ae58c9b2119?property=MVUpperLimits\n\n\nThe following JSON must also be provided with this request. This describes the current values to give to the controller for a 1 x 1 model.\n\n\n\n{\n\n  \nMVUpperLimits\n:[1]\n\n} \n\n\n\n\n\nThe following is an example of a current values for a 2 x 2 model.\n\n\n\n{\n\n  \nMVUpperLimits\n:[1,1]\n\n}\n\n\n\n\n\nUpdating a Controller's Gain\n\n\nIn order to update the gain of a controller, you may use the UpdateSpecificGain request. The URL looks as follows. \n\n\nPOST -\n\n\nhttp://localhost:9000/api/controller/UpdateSpecificGain?controllerId=302f5555-24fd-4d66-8335-2ae58c9b2119?inputCVId=1?outputMVId=1?disturbanceId=1?gain=1\n\n\nUpdate MV Gain\n\n\nPOST -\n\n\nhttp://localhost:9000/api/controller/UpdateEnabledStates?controllerId=302f5555-24fd-4d66-8335-2ae58c9b2119\n\n\nThe following JSON must be provided with this request. This describes the current values to give to the controller for a 2 x 2 model.\n\n\n\n{\n\n  \ngainValues\n:[[1,1],[1,1]]\n\n}\n\n\n\n\n\nSample (Postman)\n\n\nPostman is a graphical REST client available from the Chrome browser store. This sample shows you how to use Postman to interact with a Psibyl controller.\n\n\nCreate Controller\n\n\n\n\nStart Controller\n\n\n\n\nUpdate a controller", 
            "title": "REST Integration"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#psibyl-integration-restweb-api", 
            "text": "You can facilitate the control of a Psibyl controller using a RESTful Web API. This is the simplest and easiest way to integrate Psibyl with control platforms that are not based on the .Net Framework.    Psibyl Integration (REST/Web API)  Overview  Create a Controller  Managing a Controller  Executing a controller  Updating a Controller's Model  Updating a Controller's CV, MV and Disturbance Values  Updating a Controller's Gain  Update MV Gain    Sample (Postman)  Create Controller  Start Controller  Update a controller", 
            "title": "Psibyl Integration (REST/Web API)"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#overview", 
            "text": "At the core of Psibyl is a Web server which provides access to and storage of all MPC models. Any interaction with Psibyl requires that the Psibyl Server is running. Typically, control is done using a .Net library, provided with Psibyl, which is integrated directly into the control/execution platform (see Psibyl Controller Integration (.Net)). The Psibyl server hosts and provides access to this same API over a simple REST interface. Since any interprocess communication, from a non .Net process to a .Net process, is likely to be done with a TCP/IP protocol, it may be desirable to interact directly with the web server over TCP/IP and HTTP rather than having to write an additional interface. The following sections describe how to acheive this.", 
            "title": "Overview"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#create-a-controller", 
            "text": "The following URL demonstrates how to create a controller hosted on the Psibyl Server.  GET -  http://localhost:9000/api/controller/createcontroller?modelid={modelid}  The URL requires only the {modelid} which is an integer, identifying the model which will be used to create the controller. The following shows an example.   GET -  http://localhost:9000/api/controller/createcontroller?modelid=1  When the request is completed you should receive a response containing something similar to the following JSON. Take note of the \"Id\" field. You will need this for all subsequent requests.  \n{\n\n   $id : 1 ,\n\n   Id : 302f5555-24fd-4d66-8335-2ae58c9b2119 ,\n\n   Model :\n\n  {\n\n    ... \n\n  },\n\n   ExecutionState :0,\n\n   Lookup :null,\n\n   CVConstraintStrategy :1,\n\n   QPSolver :null,\n\n   QPMaxIterations :50,\n\n   QPTollerance :0.0001,\n\n   PredictedCVsOL :null,\n\n   PredictedCVsCL :null,\n\n   ModelId :1,\n\n   CurrentDiagnosticIteration :null\n\n}", 
            "title": "Create a Controller"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#managing-a-controller", 
            "text": "Once a controller has been created and you have the controller id, you can use the id to start and stop the controller.   To start the controller, use the following URL. This will initialize the controller, making it ready for execution.   POST -  http://localhost:9000/api/controller/Start/302f5555-24fd-4d66-8335-2ae58c9b2119  To stop the controller you can use the following URL. Once the controller has been stopped you will no longer be able to execute it.   POST -  http://localhost:9000/api/controller/Stop/302f5555-24fd-4d66-8335-2ae58c9b2119  Both requests will return a 'true' if the request succeeded.   If the request failed due to an incorrect controller id, you will receive the following error response.  \n{\n\n   Id :0,\n\n   Message : An error occured ,\n\n   ExceptionMessage : Unable to find a controller for given Id '1492b7b4-fcb7-40e0-9a83-bb5caf39318d' - Correlation Id: 1eb4db28-0376-4528-8532-eb72f8ae6e2f ,\n\n   ExceptionType : Psibyl.Service.CorrelationException ,\n\n   StackTrace :null\n\n}  When a controller has been stopped, you may wish to remove it from the server. You can do this with the following URL.   DELETE -  http://localhost:9000/api/controller/delete/302f5555-24fd-4d66-8335-2ae58c9b2119", 
            "title": "Managing a Controller"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#executing-a-controller", 
            "text": "Once a controller is started you may execute it by using the Execute request. This must be down at each execution interval and the current values must be provided. Also, as most REST clients execute asynchronously, you must make sure that you have received a response for the current iteration before sending the Execute request again. I.e. executes should be synchronous. The following is the URL used to perform an execution of the controller.   POST -  http://localhost:9000/api/controller/Execute/302f5555-24fd-4d66-8335-2ae58c9b2119  The following JSON must also be provided with this request. This describes the current values to give to the controller for a 1 x 1 model with no disturbances.  \n{\n\n   CVs :[0],\n\n   SPs :[0],\n\n   MVs :[0],\n\n   DVs :[]\n\n}  The following is an example of a current values for a 2 x 2 model with 1 disturbace.  \n{\n\n   CVs :[1,2],\n\n   SPs :[3,4],\n\n   MVs :[3,4],\n\n   DVs :[1]\n\n}  The response you will recieve from an Execute request will look as follows.  \n{\n\n   $id : 1 ,\n\n   Result :\n\n  {\n\n     $id : 2 ,\n\n     $values :[0.8331979999999999]\n\n  },\n\n   Quality :true,\n\n   ErrorId :0\n\n}", 
            "title": "Executing a controller"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#updating-a-controllers-model", 
            "text": "In order to update the model of a controller, for example, changing weights, constraints and limits. You may use the UpdateModel request. The URL looks as follows.   POST -  http://localhost:9000/api/controller/UpdateModel/302f5555-24fd-4d66-8335-2ae58c9b2119  You must provide the entire model in JSON to the request. This is best achieved by retrieving the model and then modifying the desired parameters.   The following URL demonstrates how to retrieve an MPC model.   GET -  http://localhost:9000/api/mpcmodel/Get/1  The response, which has been shortened for display purposes, should look as follows.  \n{\n\n   $id : 1 ,\n\n   Disturbances :\n\n  {\n\n     $id : 2 ,\n\n     $values :[] \n\n  },\n\n   InputCVs :\n\n  {\n\n    ...\n\n  },\n\n   OutputMVs :\n\n  {\n\n    ...\n\n  },\n\n   Id :1,\n\n   Name :  Demo Model ,\n\n   LastUpdated : \\/Date(1427714090680+0200)\\/ ,\n\n   ModelExecutionState :0,\n\n   PredictionHorizon :118,\n\n   ControlHorizon :36,\n\n   ModelHorizon :118,\n\n   SampleInterval :5,\n\n   ConstraintSoftening :true,\n\n   DateCreated : \\/Date(1427714090680+0200)\\/ ,\n\n   DateModified : \\/Date(1427878418670+0200)\\/ ,\n\n   QPMaxIterations :50,\n\n   QPTolerance :0.0001,\n\n   SysIDResults :\n\n  {\n\n    ...\n\n  },\n\n   LastSampleInterval :10\n\n}  Once the changes have been made, they must be posted back to the Update Model method using the format above.", 
            "title": "Updating a Controller's Model"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#updating-a-controllers-cv-mv-and-disturbance-values", 
            "text": "In order to update the values of a controller, you may use either the UpdateInputCVValues, UpdateOutputMVValues or the UpdateDisturbanceValues request. The URL for UpdateInputCVValues looks as follows.   POST -  http://localhost:9000/api/controller/UpdateInputCVValues?controllerId=302f5555-24fd-4d66-8335-2ae58c9b2119?property=MVUpperLimits  The following JSON must also be provided with this request. This describes the current values to give to the controller for a 1 x 1 model.  \n{\n\n   MVUpperLimits :[1]\n\n}   The following is an example of a current values for a 2 x 2 model.  \n{\n\n   MVUpperLimits :[1,1]\n\n}", 
            "title": "Updating a Controller's CV, MV and Disturbance Values"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#updating-a-controllers-gain", 
            "text": "In order to update the gain of a controller, you may use the UpdateSpecificGain request. The URL looks as follows.   POST -  http://localhost:9000/api/controller/UpdateSpecificGain?controllerId=302f5555-24fd-4d66-8335-2ae58c9b2119?inputCVId=1?outputMVId=1?disturbanceId=1?gain=1", 
            "title": "Updating a Controller's Gain"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#update-mv-gain", 
            "text": "POST -  http://localhost:9000/api/controller/UpdateEnabledStates?controllerId=302f5555-24fd-4d66-8335-2ae58c9b2119  The following JSON must be provided with this request. This describes the current values to give to the controller for a 2 x 2 model.  \n{\n\n   gainValues :[[1,1],[1,1]]\n\n}", 
            "title": "Update MV Gain"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#sample-postman", 
            "text": "Postman is a graphical REST client available from the Chrome browser store. This sample shows you how to use Postman to interact with a Psibyl controller.", 
            "title": "Sample (Postman)"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#create-controller", 
            "text": "", 
            "title": "Create Controller"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#start-controller", 
            "text": "", 
            "title": "Start Controller"
        }, 
        {
            "location": "/integration/psibyl-integration-rest/#update-a-controller", 
            "text": "", 
            "title": "Update a controller"
        }, 
        {
            "location": "/integration/psibyl-integration-service/", 
            "text": "Psibyl Control Integration (Service)\n\n\nThis page details the process for integrating Psibyl into an execution platform which will run the Psiybl controller.\n\n\nOverview\n\n\nThe following sections will decscribe each step required for setting up and running a Psibyl controller from a Visual Studio project.\n\n\n\n\n\n\nPsibyl Control Integration (Service)\n\n\nOverview\n\n\nSupported Platforms\n\n\nProject assembly references\n\n\nCreating a controller\n\n\nManaging a controller\n\n\nUpdating a controller's model\n\n\nUpdating a CV property\n\n\nUpdating a MV property\n\n\nUpdate a Disturbance property\n\n\nUpdating MV Gain Multipliers\n\n\nUpdating Disturbance Gain Multipliers\n\n\nResetting Predictions\n\n\nAccessing prediction results from execution\n\n\n\n\n\n\n\n\n\n\nSupported Platforms\n\n\nThe Psibyl controller targets the .Net 4.0 platform and above. If you're project targets .Net 3.5 or below you will need to upgrade it to target .Net 4.0 or higher.\n\n\nProject assembly references\n\n\nThere are four Psibyl .Net dlls that must be included in your project. These are,\n\n\n\n\nPsybil.Core.dll\n\n\nPsibyl.Client.dll\n\n\n\n\nIn addition to these assemblies, you must install the Microsoft Async Nu-Get package. You can do this with the following command in the Package Manager Console.\nInstall-Package Microsoft.Bcl.Async\nThis will add the following additional dlls that must be deployed with your application.\n\n\n\n\nSystem.Runtime.dll\n\n\nSystem.Threading.Tasks.dll\n\n\nSystem.IO.dll\n\n\nMicrosoft.Threading.Tasks.dll\n\n\nMicrosoft.Threading.Tasks.Extensions.Desktop.dll\n\n\nMicrosoft.Threading.Tasks.Extensions.dll\n\n\n\n\nNote:\n This only applies when integrating with an application built on .Net 4.0. When using .Net 4.5, you just need to add the assemblies normally in Visual Studio.\n\n\nCreating a controller\n\n\nThe following code snippets demonstrates how to create a controller. In order to create a controller you must first retrieve an MPC Model. This is normally an MPC model created from the Web UI. You will need to include the namespace, \nPsibyl.Client\n.\n\n\nint modelId = 1;\n\nPsibylClient client = new PsibylClient(\nhttp://localhost:9000/api\n);\nControllerProxy controller = client.Controllers.CreateController(modelId);\n\n\n\n\nOnce a controller has been created using the code above, it's state will appear as \"Idle\" in the Web UI.\n\n\nManaging a controller\n\n\nThere are three main interaction points to be aware of when working with a Psibyl controller. These are Start, Stop and Execute. Starting a controller will initialize the controller from the MPC model putting it into a state where it is ready for execution. The controller will now be in a state \"Running\". You can start a controller using the following code.\n\n\nclient.Controllers.StartController(controller.Id);\n\n\nStopping a controller will unallocate any resources being used by the controller and put it back into the \"Idle\" state. You can stop a controller using the following code.\n\n\nclient.Controllers.StopController(controller.Id);\n\n\nThe Execute method must be called on each controller iteration. You must pass the current CV's, MV's, DV's and SP's as double[] parameters. The method will return a double[] as the result. The following code demonstrates usage of the Execute method.\n\n\ndouble[] cvs = new double[] { 0 };\ndouble[] sps = new double[] { 0 };\ndouble[] mvs = new double[] { 0 };\ndouble[] dvs = new double[] { };\n\nControllerCurrentValues currentValues = new ControllerCurrentValues();\ncurrentValues.CVs = cvs;\ncurrentValues.SPs = sps;\ncurrentValues.MVs = mvs;\ncurrentValues.DVs = dvs;\n\nbool run = true;\n\nwhile (run)\n{\n    client.Controllers.ExecuteController(controller.Id, currentValues);\n    Thread.Sleep(1000);\n}\n\n\n\n\nUpdating a controller's model\n\n\nYou may change the controller's model at runtime using the following technique. This technique ensures that all clients are aware of the changes made to the model by the controller. The following code shows how to update the controllers model using the UpdateModel method. You will need to add a using statement for \nPsibyl.Core\n.\n\n\n//Retrieve the model\nMPCModel model = client.MPCModels.Get(modelId);\n\n//Change a value on the model\nmodel.InputCVs[0].Weight = 1.5;\n\n//Update the executing controllers model\nclient.Controllers.UpdateControllerModel(controller. Id, model);\n\n\n\n\nOnce UpdateModel has been called the controller will re-initialize, copying the state parameters over from the previous instance. When the controller has finished re-initializing, it swaps itself out with the old instance. Alternatively, you can use the methods below as well.\n\n\nUpdating a CV property\n\n\nCV's can be updated by specifying the property and an array of values for for each Input CV using the \nUpdateInputCVValues\n on the controller client. The following code snippet demonstrates how this can be done.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\n\n//For a controller with 2 Input CV's\ndouble[] weightValues = new double[] { 1.5, 2.5 };\nclient.Controllers.UpdateInputCVValues(controller.Id, \nWeight\n, weightValues);\n\n\n\n\nThe following is a list of properties that can be used.\n\n\n\n\nWeight\n\n\nIntegrating\n\n\nConstraintSofteningLowerWeight\n\n\nConstraintSofteningUpperWeight\n\n\nLowerConstraint\n\n\nLowerConstraintEnabled\n\n\nUpperConstraint\n\n\nUpperConstraintEnabled\n\n\nSoftLowerConstraint\n\n\nSoftLowerConstraintEnabled\n\n\nSoftUpperConstraint\n\n\nSoftUpperConstraintEnabled\n\n\nEnabled\n\n\nUpperRange\n\n\nLowerRange\n\n\n\n\nUpdating a MV property\n\n\nMV's properties can be updated much the same way as CV's using the UpdateOutputMVValues method on the controller client.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First(); \n\n//For a controller with 2 OutputMVs\ndouble[] values = new double[] { 2, 5 };\nclient.Controllers.UpdateOutputMVValues(controller.Id, \nMaxRateConstraint\n, values);\n\n\n\n\nThe following is a list of properties that can be used.\n\n\n\n\nMaxRateConstraint\n\n\nMinRateConstraint\n\n\nLowerConstraint\n\n\nLowerConstraintEnabled\n\n\nUpperConstraint\n\n\nUpperConstraintEnabled\n\n\nWeight\n\n\nMinimumStep\n\n\nEnabled\n\n\nUpperRange\n\n\nLowerRange\n\n\n\n\nUpdate a Disturbance property\n\n\nDisturbance properties can be updated much the same way as CV's and MV's using the \nUpdateDisturbanceValues\n method on the controller client.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\n\n//For a controller with 1 Disturbance\ndouble[] values = new double[] { 0 };\nlient.Controllers.UpdateDisturbanceValues(controller.Id, \nEnabled\n, values);\n\n\n\n\nThe following is a list of properties that can be used.\n\n\n\n\nEnabled\n\n\nUpperRange\n\n\nLowerRange\n\n\n\n\nUpdating MV Gain Multipliers\n\n\nMV gain multpliers can be updated using the UpdateMVGain method of the controller client. This is acheived by providing a 2D array to the method which represents the model matrix. Each element in the first array represents the Input CV and the elements of these arrays represent the CV/MV pair or step response. The following code snippet demonstrates the use of this method.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First(); \n\n//For a 2 x 2 controller with 2 Input CV's and 2 Output MV's\ndouble[][] gMult = new double[][]\n{\n    new double[] { 1, 1.5 },\n    new double[] { 1.2, 1 }\n};\n\nclient.Controllers.UpdateMVGain(controller.Id, gMult);\n\n\n\n\nUpdating Disturbance Gain Multipliers\n\n\nDisturbance gains are updated in the same way as MV gains except that the method used is  \nUpdateDisturbanceGain\n .\n\n\nResetting Predictions\n\n\nA controllers predictions can be reset using the ResetController method of the controller client. The following snippet demonstrates this.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\nclient.Controllers.ResetController(controller.Id );\n\n\n\n\nAccessing prediction results from execution\n\n\nThe following code snippet demostrates how the execution results can be accessed for trending purposes and other analysis.\n\n\nPsibyl.Client.PsibylClient client = new Client.PsibylClient(\nhttp://localhost:9000/api\n);\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\n\nControllerCurrentValues currentValues = new ControllerCurrentValues()\n{\n    CVs = new double[] { 0, 0 },\n    SPs = new double[] { 0, 0 },\n    MVs = new double[] { 0, 0 },\n    DVs = new double[] { 0, 0 },\n};\n\nControllerResult result = client.Controllers.ExecuteController(controller.Id, currentValues);\n\nfor (int i = 0; i \n result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int cvIndex = i % result.Diagnostic.Model.InputCVCount;\n    string cvName = result.Diagnostic.Model.InputCVsSequenced[cvIndex].Name;\n    double value = result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues[i].Value;\n    Console.WriteLine($\n{cvName}-YPredCL:{value}\n);\n}\nfor (int i = 0; i \n result.Diagnostic.YPredOLDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int cvIndex = i % result.Diagnostic.Model.InputCVCount;\n    string cvName = result.Diagnostic.Model.InputCVsSequenced[cvIndex].Name;\n    double value = result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues[i].Value;\n    Console.WriteLine($\n{cvName}-YPredOL:{value}\n);\n}\nfor (int i = 0; i \n result.Diagnostic.PredictedUStepsDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int mvIndex = i % result.Diagnostic.Model.OutputMVCount;\n    string mvName = result.Diagnostic.Model.OutputMVsSequenced[mvIndex].Name;\n    //Vector is also stepped, i.e each value is duplicated so that it can be trended as a step line.\n    double value = result.Diagnostic.PredictedUStepsDoubleVector.DoubleVectorValues[i + 1].Value;\n    Console.WriteLine($\n{mvName}-PredictedUSteps:{value}\n);\n}", 
            "title": "Service Integration"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#psibyl-control-integration-service", 
            "text": "This page details the process for integrating Psibyl into an execution platform which will run the Psiybl controller.", 
            "title": "Psibyl Control Integration (Service)"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#overview", 
            "text": "The following sections will decscribe each step required for setting up and running a Psibyl controller from a Visual Studio project.    Psibyl Control Integration (Service)  Overview  Supported Platforms  Project assembly references  Creating a controller  Managing a controller  Updating a controller's model  Updating a CV property  Updating a MV property  Update a Disturbance property  Updating MV Gain Multipliers  Updating Disturbance Gain Multipliers  Resetting Predictions  Accessing prediction results from execution", 
            "title": "Overview"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#supported-platforms", 
            "text": "The Psibyl controller targets the .Net 4.0 platform and above. If you're project targets .Net 3.5 or below you will need to upgrade it to target .Net 4.0 or higher.", 
            "title": "Supported Platforms"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#project-assembly-references", 
            "text": "There are four Psibyl .Net dlls that must be included in your project. These are,   Psybil.Core.dll  Psibyl.Client.dll   In addition to these assemblies, you must install the Microsoft Async Nu-Get package. You can do this with the following command in the Package Manager Console.\nInstall-Package Microsoft.Bcl.Async\nThis will add the following additional dlls that must be deployed with your application.   System.Runtime.dll  System.Threading.Tasks.dll  System.IO.dll  Microsoft.Threading.Tasks.dll  Microsoft.Threading.Tasks.Extensions.Desktop.dll  Microsoft.Threading.Tasks.Extensions.dll   Note:  This only applies when integrating with an application built on .Net 4.0. When using .Net 4.5, you just need to add the assemblies normally in Visual Studio.", 
            "title": "Project assembly references"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#creating-a-controller", 
            "text": "The following code snippets demonstrates how to create a controller. In order to create a controller you must first retrieve an MPC Model. This is normally an MPC model created from the Web UI. You will need to include the namespace,  Psibyl.Client .  int modelId = 1;\n\nPsibylClient client = new PsibylClient( http://localhost:9000/api );\nControllerProxy controller = client.Controllers.CreateController(modelId);  Once a controller has been created using the code above, it's state will appear as \"Idle\" in the Web UI.", 
            "title": "Creating a controller"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#managing-a-controller", 
            "text": "There are three main interaction points to be aware of when working with a Psibyl controller. These are Start, Stop and Execute. Starting a controller will initialize the controller from the MPC model putting it into a state where it is ready for execution. The controller will now be in a state \"Running\". You can start a controller using the following code.  client.Controllers.StartController(controller.Id);  Stopping a controller will unallocate any resources being used by the controller and put it back into the \"Idle\" state. You can stop a controller using the following code.  client.Controllers.StopController(controller.Id);  The Execute method must be called on each controller iteration. You must pass the current CV's, MV's, DV's and SP's as double[] parameters. The method will return a double[] as the result. The following code demonstrates usage of the Execute method.  double[] cvs = new double[] { 0 };\ndouble[] sps = new double[] { 0 };\ndouble[] mvs = new double[] { 0 };\ndouble[] dvs = new double[] { };\n\nControllerCurrentValues currentValues = new ControllerCurrentValues();\ncurrentValues.CVs = cvs;\ncurrentValues.SPs = sps;\ncurrentValues.MVs = mvs;\ncurrentValues.DVs = dvs;\n\nbool run = true;\n\nwhile (run)\n{\n    client.Controllers.ExecuteController(controller.Id, currentValues);\n    Thread.Sleep(1000);\n}", 
            "title": "Managing a controller"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#updating-a-controllers-model", 
            "text": "You may change the controller's model at runtime using the following technique. This technique ensures that all clients are aware of the changes made to the model by the controller. The following code shows how to update the controllers model using the UpdateModel method. You will need to add a using statement for  Psibyl.Core .  //Retrieve the model\nMPCModel model = client.MPCModels.Get(modelId);\n\n//Change a value on the model\nmodel.InputCVs[0].Weight = 1.5;\n\n//Update the executing controllers model\nclient.Controllers.UpdateControllerModel(controller. Id, model);  Once UpdateModel has been called the controller will re-initialize, copying the state parameters over from the previous instance. When the controller has finished re-initializing, it swaps itself out with the old instance. Alternatively, you can use the methods below as well.", 
            "title": "Updating a controller's model"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#updating-a-cv-property", 
            "text": "CV's can be updated by specifying the property and an array of values for for each Input CV using the  UpdateInputCVValues  on the controller client. The following code snippet demonstrates how this can be done.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\n\n//For a controller with 2 Input CV's\ndouble[] weightValues = new double[] { 1.5, 2.5 };\nclient.Controllers.UpdateInputCVValues(controller.Id,  Weight , weightValues);  The following is a list of properties that can be used.   Weight  Integrating  ConstraintSofteningLowerWeight  ConstraintSofteningUpperWeight  LowerConstraint  LowerConstraintEnabled  UpperConstraint  UpperConstraintEnabled  SoftLowerConstraint  SoftLowerConstraintEnabled  SoftUpperConstraint  SoftUpperConstraintEnabled  Enabled  UpperRange  LowerRange", 
            "title": "Updating a CV property"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#updating-a-mv-property", 
            "text": "MV's properties can be updated much the same way as CV's using the UpdateOutputMVValues method on the controller client.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First(); \n\n//For a controller with 2 OutputMVs\ndouble[] values = new double[] { 2, 5 };\nclient.Controllers.UpdateOutputMVValues(controller.Id,  MaxRateConstraint , values);  The following is a list of properties that can be used.   MaxRateConstraint  MinRateConstraint  LowerConstraint  LowerConstraintEnabled  UpperConstraint  UpperConstraintEnabled  Weight  MinimumStep  Enabled  UpperRange  LowerRange", 
            "title": "Updating a MV property"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#update-a-disturbance-property", 
            "text": "Disturbance properties can be updated much the same way as CV's and MV's using the  UpdateDisturbanceValues  method on the controller client.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\n\n//For a controller with 1 Disturbance\ndouble[] values = new double[] { 0 };\nlient.Controllers.UpdateDisturbanceValues(controller.Id,  Enabled , values);  The following is a list of properties that can be used.   Enabled  UpperRange  LowerRange", 
            "title": "Update a Disturbance property"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#updating-mv-gain-multipliers", 
            "text": "MV gain multpliers can be updated using the UpdateMVGain method of the controller client. This is acheived by providing a 2D array to the method which represents the model matrix. Each element in the first array represents the Input CV and the elements of these arrays represent the CV/MV pair or step response. The following code snippet demonstrates the use of this method.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First(); \n\n//For a 2 x 2 controller with 2 Input CV's and 2 Output MV's\ndouble[][] gMult = new double[][]\n{\n    new double[] { 1, 1.5 },\n    new double[] { 1.2, 1 }\n};\n\nclient.Controllers.UpdateMVGain(controller.Id, gMult);", 
            "title": "Updating MV Gain Multipliers"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#updating-disturbance-gain-multipliers", 
            "text": "Disturbance gains are updated in the same way as MV gains except that the method used is   UpdateDisturbanceGain  .", 
            "title": "Updating Disturbance Gain Multipliers"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#resetting-predictions", 
            "text": "A controllers predictions can be reset using the ResetController method of the controller client. The following snippet demonstrates this.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\nclient.Controllers.ResetController(controller.Id );", 
            "title": "Resetting Predictions"
        }, 
        {
            "location": "/integration/psibyl-integration-service/#accessing-prediction-results-from-execution", 
            "text": "The following code snippet demostrates how the execution results can be accessed for trending purposes and other analysis.  Psibyl.Client.PsibylClient client = new Client.PsibylClient( http://localhost:9000/api );\nPsibyl.Client.ControllerProxy controller = client.Controllers.GetControllers().First();\n\nControllerCurrentValues currentValues = new ControllerCurrentValues()\n{\n    CVs = new double[] { 0, 0 },\n    SPs = new double[] { 0, 0 },\n    MVs = new double[] { 0, 0 },\n    DVs = new double[] { 0, 0 },\n};\n\nControllerResult result = client.Controllers.ExecuteController(controller.Id, currentValues);\n\nfor (int i = 0; i   result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int cvIndex = i % result.Diagnostic.Model.InputCVCount;\n    string cvName = result.Diagnostic.Model.InputCVsSequenced[cvIndex].Name;\n    double value = result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues[i].Value;\n    Console.WriteLine($ {cvName}-YPredCL:{value} );\n}\nfor (int i = 0; i   result.Diagnostic.YPredOLDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int cvIndex = i % result.Diagnostic.Model.InputCVCount;\n    string cvName = result.Diagnostic.Model.InputCVsSequenced[cvIndex].Name;\n    double value = result.Diagnostic.YPredCLDoubleVector.DoubleVectorValues[i].Value;\n    Console.WriteLine($ {cvName}-YPredOL:{value} );\n}\nfor (int i = 0; i   result.Diagnostic.PredictedUStepsDoubleVector.DoubleVectorValues.Count; i++)\n{\n    //Vector is packed such that the values alternate between the number of CVs\n    int mvIndex = i % result.Diagnostic.Model.OutputMVCount;\n    string mvName = result.Diagnostic.Model.OutputMVsSequenced[mvIndex].Name;\n    //Vector is also stepped, i.e each value is duplicated so that it can be trended as a step line.\n    double value = result.Diagnostic.PredictedUStepsDoubleVector.DoubleVectorValues[i + 1].Value;\n    Console.WriteLine($ {mvName}-PredictedUSteps:{value} );\n}", 
            "title": "Accessing prediction results from execution"
        }
    ]
}